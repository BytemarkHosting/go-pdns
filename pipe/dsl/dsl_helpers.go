// AUTOGENERATED helper methods for IANA-registered RRTYPES. Do not edit.
// See generate_dsl_helpers.sh for details
package dsl

import (
	"fmt"
	"regexp"
)

var RRTypes = []string{
	"A",
	"AAAA",
	"AFSDB",
	"APL",
	"ATMA",
	"AXFR",
	"CAA",
	"CDNSKEY",
	"CDS",
	"CERT",
	"CNAME",
	"DHCID",
	"DLV",
	"DNAME",
	"DNSKEY",
	"DS",
	"EID",
	"GID",
	"GPOS",
	"HINFO",
	"HIP",
	"IPSECKEY",
	"ISDN",
	"IXFR",
	"KEY",
	"KX",
	"LOC",
	"LP",
	"MAILA",
	"MAILB",
	"MB",
	"MD",
	"MF",
	"MG",
	"MINFO",
	"MR",
	"MX",
	"NAPTR",
	"NID",
	"NIMLOC",
	"NINFO",
	"NS",
	"NSAP",
	"NSEC",
	"NULL",
	"NXT",
	"OPENPGPKEY",
	"OPT",
	"PTR",
	"PX",
	"RKEY",
	"RP",
	"RRSIG",
	"RT",
	"SIG",
	"SINK",
	"SOA",
	"SPF",
	"SRV",
	"SSHFP",
	"TA",
	"TALINK",
	"TKEY",
	"TLSA",
	"TSIG",
	"TXT",
	"TYPE",
	"UID",
	"UINFO",
	"UNSPEC",
	"URI",
	"WKS",
}

// Helper function to register a callback for A queries.
// The matcher is given as a string, which is compiled to a regular expression
// (using regexp.MustCompile) with the following rules:
//
// * The regexp is anchored to the start of the match string("^" at start)
// * The case-insensitivity option is added "(?i)"
// * The regexp is anchored to the end of the match string ("$" at end)
//
// If any of these options are unwelcome, you can use the DSL.Register and pass
// a regexp and the "A" string directly.
func (d *DSL) A(matcher string, f Callback) {
	re := regexp.MustCompile(fmt.Sprintf("^(?i)%s$", matcher))
	d.Register("A", re, f)
}

// Helper function to register a callback for AAAA queries.
// The matcher is given as a string, which is compiled to a regular expression
// (using regexp.MustCompile) with the following rules:
//
// * The regexp is anchored to the start of the match string("^" at start)
// * The case-insensitivity option is added "(?i)"
// * The regexp is anchored to the end of the match string ("$" at end)
//
// If any of these options are unwelcome, you can use the DSL.Register and pass
// a regexp and the "AAAA" string directly.
func (d *DSL) AAAA(matcher string, f Callback) {
	re := regexp.MustCompile(fmt.Sprintf("^(?i)%s$", matcher))
	d.Register("AAAA", re, f)
}

// Helper function to register a callback for AFSDB queries.
// The matcher is given as a string, which is compiled to a regular expression
// (using regexp.MustCompile) with the following rules:
//
// * The regexp is anchored to the start of the match string("^" at start)
// * The case-insensitivity option is added "(?i)"
// * The regexp is anchored to the end of the match string ("$" at end)
//
// If any of these options are unwelcome, you can use the DSL.Register and pass
// a regexp and the "AFSDB" string directly.
func (d *DSL) AFSDB(matcher string, f Callback) {
	re := regexp.MustCompile(fmt.Sprintf("^(?i)%s$", matcher))
	d.Register("AFSDB", re, f)
}

// Helper function to register a callback for APL queries.
// The matcher is given as a string, which is compiled to a regular expression
// (using regexp.MustCompile) with the following rules:
//
// * The regexp is anchored to the start of the match string("^" at start)
// * The case-insensitivity option is added "(?i)"
// * The regexp is anchored to the end of the match string ("$" at end)
//
// If any of these options are unwelcome, you can use the DSL.Register and pass
// a regexp and the "APL" string directly.
func (d *DSL) APL(matcher string, f Callback) {
	re := regexp.MustCompile(fmt.Sprintf("^(?i)%s$", matcher))
	d.Register("APL", re, f)
}

// Helper function to register a callback for ATMA queries.
// The matcher is given as a string, which is compiled to a regular expression
// (using regexp.MustCompile) with the following rules:
//
// * The regexp is anchored to the start of the match string("^" at start)
// * The case-insensitivity option is added "(?i)"
// * The regexp is anchored to the end of the match string ("$" at end)
//
// If any of these options are unwelcome, you can use the DSL.Register and pass
// a regexp and the "ATMA" string directly.
func (d *DSL) ATMA(matcher string, f Callback) {
	re := regexp.MustCompile(fmt.Sprintf("^(?i)%s$", matcher))
	d.Register("ATMA", re, f)
}

// Helper function to register a callback for AXFR queries.
// The matcher is given as a string, which is compiled to a regular expression
// (using regexp.MustCompile) with the following rules:
//
// * The regexp is anchored to the start of the match string("^" at start)
// * The case-insensitivity option is added "(?i)"
// * The regexp is anchored to the end of the match string ("$" at end)
//
// If any of these options are unwelcome, you can use the DSL.Register and pass
// a regexp and the "AXFR" string directly.
func (d *DSL) AXFR(matcher string, f Callback) {
	re := regexp.MustCompile(fmt.Sprintf("^(?i)%s$", matcher))
	d.Register("AXFR", re, f)
}

// Helper function to register a callback for CAA queries.
// The matcher is given as a string, which is compiled to a regular expression
// (using regexp.MustCompile) with the following rules:
//
// * The regexp is anchored to the start of the match string("^" at start)
// * The case-insensitivity option is added "(?i)"
// * The regexp is anchored to the end of the match string ("$" at end)
//
// If any of these options are unwelcome, you can use the DSL.Register and pass
// a regexp and the "CAA" string directly.
func (d *DSL) CAA(matcher string, f Callback) {
	re := regexp.MustCompile(fmt.Sprintf("^(?i)%s$", matcher))
	d.Register("CAA", re, f)
}

// Helper function to register a callback for CDNSKEY queries.
// The matcher is given as a string, which is compiled to a regular expression
// (using regexp.MustCompile) with the following rules:
//
// * The regexp is anchored to the start of the match string("^" at start)
// * The case-insensitivity option is added "(?i)"
// * The regexp is anchored to the end of the match string ("$" at end)
//
// If any of these options are unwelcome, you can use the DSL.Register and pass
// a regexp and the "CDNSKEY" string directly.
func (d *DSL) CDNSKEY(matcher string, f Callback) {
	re := regexp.MustCompile(fmt.Sprintf("^(?i)%s$", matcher))
	d.Register("CDNSKEY", re, f)
}

// Helper function to register a callback for CDS queries.
// The matcher is given as a string, which is compiled to a regular expression
// (using regexp.MustCompile) with the following rules:
//
// * The regexp is anchored to the start of the match string("^" at start)
// * The case-insensitivity option is added "(?i)"
// * The regexp is anchored to the end of the match string ("$" at end)
//
// If any of these options are unwelcome, you can use the DSL.Register and pass
// a regexp and the "CDS" string directly.
func (d *DSL) CDS(matcher string, f Callback) {
	re := regexp.MustCompile(fmt.Sprintf("^(?i)%s$", matcher))
	d.Register("CDS", re, f)
}

// Helper function to register a callback for CERT queries.
// The matcher is given as a string, which is compiled to a regular expression
// (using regexp.MustCompile) with the following rules:
//
// * The regexp is anchored to the start of the match string("^" at start)
// * The case-insensitivity option is added "(?i)"
// * The regexp is anchored to the end of the match string ("$" at end)
//
// If any of these options are unwelcome, you can use the DSL.Register and pass
// a regexp and the "CERT" string directly.
func (d *DSL) CERT(matcher string, f Callback) {
	re := regexp.MustCompile(fmt.Sprintf("^(?i)%s$", matcher))
	d.Register("CERT", re, f)
}

// Helper function to register a callback for CNAME queries.
// The matcher is given as a string, which is compiled to a regular expression
// (using regexp.MustCompile) with the following rules:
//
// * The regexp is anchored to the start of the match string("^" at start)
// * The case-insensitivity option is added "(?i)"
// * The regexp is anchored to the end of the match string ("$" at end)
//
// If any of these options are unwelcome, you can use the DSL.Register and pass
// a regexp and the "CNAME" string directly.
func (d *DSL) CNAME(matcher string, f Callback) {
	re := regexp.MustCompile(fmt.Sprintf("^(?i)%s$", matcher))
	d.Register("CNAME", re, f)
}

// Helper function to register a callback for DHCID queries.
// The matcher is given as a string, which is compiled to a regular expression
// (using regexp.MustCompile) with the following rules:
//
// * The regexp is anchored to the start of the match string("^" at start)
// * The case-insensitivity option is added "(?i)"
// * The regexp is anchored to the end of the match string ("$" at end)
//
// If any of these options are unwelcome, you can use the DSL.Register and pass
// a regexp and the "DHCID" string directly.
func (d *DSL) DHCID(matcher string, f Callback) {
	re := regexp.MustCompile(fmt.Sprintf("^(?i)%s$", matcher))
	d.Register("DHCID", re, f)
}

// Helper function to register a callback for DLV queries.
// The matcher is given as a string, which is compiled to a regular expression
// (using regexp.MustCompile) with the following rules:
//
// * The regexp is anchored to the start of the match string("^" at start)
// * The case-insensitivity option is added "(?i)"
// * The regexp is anchored to the end of the match string ("$" at end)
//
// If any of these options are unwelcome, you can use the DSL.Register and pass
// a regexp and the "DLV" string directly.
func (d *DSL) DLV(matcher string, f Callback) {
	re := regexp.MustCompile(fmt.Sprintf("^(?i)%s$", matcher))
	d.Register("DLV", re, f)
}

// Helper function to register a callback for DNAME queries.
// The matcher is given as a string, which is compiled to a regular expression
// (using regexp.MustCompile) with the following rules:
//
// * The regexp is anchored to the start of the match string("^" at start)
// * The case-insensitivity option is added "(?i)"
// * The regexp is anchored to the end of the match string ("$" at end)
//
// If any of these options are unwelcome, you can use the DSL.Register and pass
// a regexp and the "DNAME" string directly.
func (d *DSL) DNAME(matcher string, f Callback) {
	re := regexp.MustCompile(fmt.Sprintf("^(?i)%s$", matcher))
	d.Register("DNAME", re, f)
}

// Helper function to register a callback for DNSKEY queries.
// The matcher is given as a string, which is compiled to a regular expression
// (using regexp.MustCompile) with the following rules:
//
// * The regexp is anchored to the start of the match string("^" at start)
// * The case-insensitivity option is added "(?i)"
// * The regexp is anchored to the end of the match string ("$" at end)
//
// If any of these options are unwelcome, you can use the DSL.Register and pass
// a regexp and the "DNSKEY" string directly.
func (d *DSL) DNSKEY(matcher string, f Callback) {
	re := regexp.MustCompile(fmt.Sprintf("^(?i)%s$", matcher))
	d.Register("DNSKEY", re, f)
}

// Helper function to register a callback for DS queries.
// The matcher is given as a string, which is compiled to a regular expression
// (using regexp.MustCompile) with the following rules:
//
// * The regexp is anchored to the start of the match string("^" at start)
// * The case-insensitivity option is added "(?i)"
// * The regexp is anchored to the end of the match string ("$" at end)
//
// If any of these options are unwelcome, you can use the DSL.Register and pass
// a regexp and the "DS" string directly.
func (d *DSL) DS(matcher string, f Callback) {
	re := regexp.MustCompile(fmt.Sprintf("^(?i)%s$", matcher))
	d.Register("DS", re, f)
}

// Helper function to register a callback for EID queries.
// The matcher is given as a string, which is compiled to a regular expression
// (using regexp.MustCompile) with the following rules:
//
// * The regexp is anchored to the start of the match string("^" at start)
// * The case-insensitivity option is added "(?i)"
// * The regexp is anchored to the end of the match string ("$" at end)
//
// If any of these options are unwelcome, you can use the DSL.Register and pass
// a regexp and the "EID" string directly.
func (d *DSL) EID(matcher string, f Callback) {
	re := regexp.MustCompile(fmt.Sprintf("^(?i)%s$", matcher))
	d.Register("EID", re, f)
}

// Helper function to register a callback for GID queries.
// The matcher is given as a string, which is compiled to a regular expression
// (using regexp.MustCompile) with the following rules:
//
// * The regexp is anchored to the start of the match string("^" at start)
// * The case-insensitivity option is added "(?i)"
// * The regexp is anchored to the end of the match string ("$" at end)
//
// If any of these options are unwelcome, you can use the DSL.Register and pass
// a regexp and the "GID" string directly.
func (d *DSL) GID(matcher string, f Callback) {
	re := regexp.MustCompile(fmt.Sprintf("^(?i)%s$", matcher))
	d.Register("GID", re, f)
}

// Helper function to register a callback for GPOS queries.
// The matcher is given as a string, which is compiled to a regular expression
// (using regexp.MustCompile) with the following rules:
//
// * The regexp is anchored to the start of the match string("^" at start)
// * The case-insensitivity option is added "(?i)"
// * The regexp is anchored to the end of the match string ("$" at end)
//
// If any of these options are unwelcome, you can use the DSL.Register and pass
// a regexp and the "GPOS" string directly.
func (d *DSL) GPOS(matcher string, f Callback) {
	re := regexp.MustCompile(fmt.Sprintf("^(?i)%s$", matcher))
	d.Register("GPOS", re, f)
}

// Helper function to register a callback for HINFO queries.
// The matcher is given as a string, which is compiled to a regular expression
// (using regexp.MustCompile) with the following rules:
//
// * The regexp is anchored to the start of the match string("^" at start)
// * The case-insensitivity option is added "(?i)"
// * The regexp is anchored to the end of the match string ("$" at end)
//
// If any of these options are unwelcome, you can use the DSL.Register and pass
// a regexp and the "HINFO" string directly.
func (d *DSL) HINFO(matcher string, f Callback) {
	re := regexp.MustCompile(fmt.Sprintf("^(?i)%s$", matcher))
	d.Register("HINFO", re, f)
}

// Helper function to register a callback for HIP queries.
// The matcher is given as a string, which is compiled to a regular expression
// (using regexp.MustCompile) with the following rules:
//
// * The regexp is anchored to the start of the match string("^" at start)
// * The case-insensitivity option is added "(?i)"
// * The regexp is anchored to the end of the match string ("$" at end)
//
// If any of these options are unwelcome, you can use the DSL.Register and pass
// a regexp and the "HIP" string directly.
func (d *DSL) HIP(matcher string, f Callback) {
	re := regexp.MustCompile(fmt.Sprintf("^(?i)%s$", matcher))
	d.Register("HIP", re, f)
}

// Helper function to register a callback for IPSECKEY queries.
// The matcher is given as a string, which is compiled to a regular expression
// (using regexp.MustCompile) with the following rules:
//
// * The regexp is anchored to the start of the match string("^" at start)
// * The case-insensitivity option is added "(?i)"
// * The regexp is anchored to the end of the match string ("$" at end)
//
// If any of these options are unwelcome, you can use the DSL.Register and pass
// a regexp and the "IPSECKEY" string directly.
func (d *DSL) IPSECKEY(matcher string, f Callback) {
	re := regexp.MustCompile(fmt.Sprintf("^(?i)%s$", matcher))
	d.Register("IPSECKEY", re, f)
}

// Helper function to register a callback for ISDN queries.
// The matcher is given as a string, which is compiled to a regular expression
// (using regexp.MustCompile) with the following rules:
//
// * The regexp is anchored to the start of the match string("^" at start)
// * The case-insensitivity option is added "(?i)"
// * The regexp is anchored to the end of the match string ("$" at end)
//
// If any of these options are unwelcome, you can use the DSL.Register and pass
// a regexp and the "ISDN" string directly.
func (d *DSL) ISDN(matcher string, f Callback) {
	re := regexp.MustCompile(fmt.Sprintf("^(?i)%s$", matcher))
	d.Register("ISDN", re, f)
}

// Helper function to register a callback for IXFR queries.
// The matcher is given as a string, which is compiled to a regular expression
// (using regexp.MustCompile) with the following rules:
//
// * The regexp is anchored to the start of the match string("^" at start)
// * The case-insensitivity option is added "(?i)"
// * The regexp is anchored to the end of the match string ("$" at end)
//
// If any of these options are unwelcome, you can use the DSL.Register and pass
// a regexp and the "IXFR" string directly.
func (d *DSL) IXFR(matcher string, f Callback) {
	re := regexp.MustCompile(fmt.Sprintf("^(?i)%s$", matcher))
	d.Register("IXFR", re, f)
}

// Helper function to register a callback for KEY queries.
// The matcher is given as a string, which is compiled to a regular expression
// (using regexp.MustCompile) with the following rules:
//
// * The regexp is anchored to the start of the match string("^" at start)
// * The case-insensitivity option is added "(?i)"
// * The regexp is anchored to the end of the match string ("$" at end)
//
// If any of these options are unwelcome, you can use the DSL.Register and pass
// a regexp and the "KEY" string directly.
func (d *DSL) KEY(matcher string, f Callback) {
	re := regexp.MustCompile(fmt.Sprintf("^(?i)%s$", matcher))
	d.Register("KEY", re, f)
}

// Helper function to register a callback for KX queries.
// The matcher is given as a string, which is compiled to a regular expression
// (using regexp.MustCompile) with the following rules:
//
// * The regexp is anchored to the start of the match string("^" at start)
// * The case-insensitivity option is added "(?i)"
// * The regexp is anchored to the end of the match string ("$" at end)
//
// If any of these options are unwelcome, you can use the DSL.Register and pass
// a regexp and the "KX" string directly.
func (d *DSL) KX(matcher string, f Callback) {
	re := regexp.MustCompile(fmt.Sprintf("^(?i)%s$", matcher))
	d.Register("KX", re, f)
}

// Helper function to register a callback for LOC queries.
// The matcher is given as a string, which is compiled to a regular expression
// (using regexp.MustCompile) with the following rules:
//
// * The regexp is anchored to the start of the match string("^" at start)
// * The case-insensitivity option is added "(?i)"
// * The regexp is anchored to the end of the match string ("$" at end)
//
// If any of these options are unwelcome, you can use the DSL.Register and pass
// a regexp and the "LOC" string directly.
func (d *DSL) LOC(matcher string, f Callback) {
	re := regexp.MustCompile(fmt.Sprintf("^(?i)%s$", matcher))
	d.Register("LOC", re, f)
}

// Helper function to register a callback for LP queries.
// The matcher is given as a string, which is compiled to a regular expression
// (using regexp.MustCompile) with the following rules:
//
// * The regexp is anchored to the start of the match string("^" at start)
// * The case-insensitivity option is added "(?i)"
// * The regexp is anchored to the end of the match string ("$" at end)
//
// If any of these options are unwelcome, you can use the DSL.Register and pass
// a regexp and the "LP" string directly.
func (d *DSL) LP(matcher string, f Callback) {
	re := regexp.MustCompile(fmt.Sprintf("^(?i)%s$", matcher))
	d.Register("LP", re, f)
}

// Helper function to register a callback for MAILA queries.
// The matcher is given as a string, which is compiled to a regular expression
// (using regexp.MustCompile) with the following rules:
//
// * The regexp is anchored to the start of the match string("^" at start)
// * The case-insensitivity option is added "(?i)"
// * The regexp is anchored to the end of the match string ("$" at end)
//
// If any of these options are unwelcome, you can use the DSL.Register and pass
// a regexp and the "MAILA" string directly.
func (d *DSL) MAILA(matcher string, f Callback) {
	re := regexp.MustCompile(fmt.Sprintf("^(?i)%s$", matcher))
	d.Register("MAILA", re, f)
}

// Helper function to register a callback for MAILB queries.
// The matcher is given as a string, which is compiled to a regular expression
// (using regexp.MustCompile) with the following rules:
//
// * The regexp is anchored to the start of the match string("^" at start)
// * The case-insensitivity option is added "(?i)"
// * The regexp is anchored to the end of the match string ("$" at end)
//
// If any of these options are unwelcome, you can use the DSL.Register and pass
// a regexp and the "MAILB" string directly.
func (d *DSL) MAILB(matcher string, f Callback) {
	re := regexp.MustCompile(fmt.Sprintf("^(?i)%s$", matcher))
	d.Register("MAILB", re, f)
}

// Helper function to register a callback for MB queries.
// The matcher is given as a string, which is compiled to a regular expression
// (using regexp.MustCompile) with the following rules:
//
// * The regexp is anchored to the start of the match string("^" at start)
// * The case-insensitivity option is added "(?i)"
// * The regexp is anchored to the end of the match string ("$" at end)
//
// If any of these options are unwelcome, you can use the DSL.Register and pass
// a regexp and the "MB" string directly.
func (d *DSL) MB(matcher string, f Callback) {
	re := regexp.MustCompile(fmt.Sprintf("^(?i)%s$", matcher))
	d.Register("MB", re, f)
}

// Helper function to register a callback for MD queries.
// The matcher is given as a string, which is compiled to a regular expression
// (using regexp.MustCompile) with the following rules:
//
// * The regexp is anchored to the start of the match string("^" at start)
// * The case-insensitivity option is added "(?i)"
// * The regexp is anchored to the end of the match string ("$" at end)
//
// If any of these options are unwelcome, you can use the DSL.Register and pass
// a regexp and the "MD" string directly.
func (d *DSL) MD(matcher string, f Callback) {
	re := regexp.MustCompile(fmt.Sprintf("^(?i)%s$", matcher))
	d.Register("MD", re, f)
}

// Helper function to register a callback for MF queries.
// The matcher is given as a string, which is compiled to a regular expression
// (using regexp.MustCompile) with the following rules:
//
// * The regexp is anchored to the start of the match string("^" at start)
// * The case-insensitivity option is added "(?i)"
// * The regexp is anchored to the end of the match string ("$" at end)
//
// If any of these options are unwelcome, you can use the DSL.Register and pass
// a regexp and the "MF" string directly.
func (d *DSL) MF(matcher string, f Callback) {
	re := regexp.MustCompile(fmt.Sprintf("^(?i)%s$", matcher))
	d.Register("MF", re, f)
}

// Helper function to register a callback for MG queries.
// The matcher is given as a string, which is compiled to a regular expression
// (using regexp.MustCompile) with the following rules:
//
// * The regexp is anchored to the start of the match string("^" at start)
// * The case-insensitivity option is added "(?i)"
// * The regexp is anchored to the end of the match string ("$" at end)
//
// If any of these options are unwelcome, you can use the DSL.Register and pass
// a regexp and the "MG" string directly.
func (d *DSL) MG(matcher string, f Callback) {
	re := regexp.MustCompile(fmt.Sprintf("^(?i)%s$", matcher))
	d.Register("MG", re, f)
}

// Helper function to register a callback for MINFO queries.
// The matcher is given as a string, which is compiled to a regular expression
// (using regexp.MustCompile) with the following rules:
//
// * The regexp is anchored to the start of the match string("^" at start)
// * The case-insensitivity option is added "(?i)"
// * The regexp is anchored to the end of the match string ("$" at end)
//
// If any of these options are unwelcome, you can use the DSL.Register and pass
// a regexp and the "MINFO" string directly.
func (d *DSL) MINFO(matcher string, f Callback) {
	re := regexp.MustCompile(fmt.Sprintf("^(?i)%s$", matcher))
	d.Register("MINFO", re, f)
}

// Helper function to register a callback for MR queries.
// The matcher is given as a string, which is compiled to a regular expression
// (using regexp.MustCompile) with the following rules:
//
// * The regexp is anchored to the start of the match string("^" at start)
// * The case-insensitivity option is added "(?i)"
// * The regexp is anchored to the end of the match string ("$" at end)
//
// If any of these options are unwelcome, you can use the DSL.Register and pass
// a regexp and the "MR" string directly.
func (d *DSL) MR(matcher string, f Callback) {
	re := regexp.MustCompile(fmt.Sprintf("^(?i)%s$", matcher))
	d.Register("MR", re, f)
}

// Helper function to register a callback for MX queries.
// The matcher is given as a string, which is compiled to a regular expression
// (using regexp.MustCompile) with the following rules:
//
// * The regexp is anchored to the start of the match string("^" at start)
// * The case-insensitivity option is added "(?i)"
// * The regexp is anchored to the end of the match string ("$" at end)
//
// If any of these options are unwelcome, you can use the DSL.Register and pass
// a regexp and the "MX" string directly.
func (d *DSL) MX(matcher string, f Callback) {
	re := regexp.MustCompile(fmt.Sprintf("^(?i)%s$", matcher))
	d.Register("MX", re, f)
}

// Helper function to register a callback for NAPTR queries.
// The matcher is given as a string, which is compiled to a regular expression
// (using regexp.MustCompile) with the following rules:
//
// * The regexp is anchored to the start of the match string("^" at start)
// * The case-insensitivity option is added "(?i)"
// * The regexp is anchored to the end of the match string ("$" at end)
//
// If any of these options are unwelcome, you can use the DSL.Register and pass
// a regexp and the "NAPTR" string directly.
func (d *DSL) NAPTR(matcher string, f Callback) {
	re := regexp.MustCompile(fmt.Sprintf("^(?i)%s$", matcher))
	d.Register("NAPTR", re, f)
}

// Helper function to register a callback for NID queries.
// The matcher is given as a string, which is compiled to a regular expression
// (using regexp.MustCompile) with the following rules:
//
// * The regexp is anchored to the start of the match string("^" at start)
// * The case-insensitivity option is added "(?i)"
// * The regexp is anchored to the end of the match string ("$" at end)
//
// If any of these options are unwelcome, you can use the DSL.Register and pass
// a regexp and the "NID" string directly.
func (d *DSL) NID(matcher string, f Callback) {
	re := regexp.MustCompile(fmt.Sprintf("^(?i)%s$", matcher))
	d.Register("NID", re, f)
}

// Helper function to register a callback for NIMLOC queries.
// The matcher is given as a string, which is compiled to a regular expression
// (using regexp.MustCompile) with the following rules:
//
// * The regexp is anchored to the start of the match string("^" at start)
// * The case-insensitivity option is added "(?i)"
// * The regexp is anchored to the end of the match string ("$" at end)
//
// If any of these options are unwelcome, you can use the DSL.Register and pass
// a regexp and the "NIMLOC" string directly.
func (d *DSL) NIMLOC(matcher string, f Callback) {
	re := regexp.MustCompile(fmt.Sprintf("^(?i)%s$", matcher))
	d.Register("NIMLOC", re, f)
}

// Helper function to register a callback for NINFO queries.
// The matcher is given as a string, which is compiled to a regular expression
// (using regexp.MustCompile) with the following rules:
//
// * The regexp is anchored to the start of the match string("^" at start)
// * The case-insensitivity option is added "(?i)"
// * The regexp is anchored to the end of the match string ("$" at end)
//
// If any of these options are unwelcome, you can use the DSL.Register and pass
// a regexp and the "NINFO" string directly.
func (d *DSL) NINFO(matcher string, f Callback) {
	re := regexp.MustCompile(fmt.Sprintf("^(?i)%s$", matcher))
	d.Register("NINFO", re, f)
}

// Helper function to register a callback for NS queries.
// The matcher is given as a string, which is compiled to a regular expression
// (using regexp.MustCompile) with the following rules:
//
// * The regexp is anchored to the start of the match string("^" at start)
// * The case-insensitivity option is added "(?i)"
// * The regexp is anchored to the end of the match string ("$" at end)
//
// If any of these options are unwelcome, you can use the DSL.Register and pass
// a regexp and the "NS" string directly.
func (d *DSL) NS(matcher string, f Callback) {
	re := regexp.MustCompile(fmt.Sprintf("^(?i)%s$", matcher))
	d.Register("NS", re, f)
}

// Helper function to register a callback for NSAP queries.
// The matcher is given as a string, which is compiled to a regular expression
// (using regexp.MustCompile) with the following rules:
//
// * The regexp is anchored to the start of the match string("^" at start)
// * The case-insensitivity option is added "(?i)"
// * The regexp is anchored to the end of the match string ("$" at end)
//
// If any of these options are unwelcome, you can use the DSL.Register and pass
// a regexp and the "NSAP" string directly.
func (d *DSL) NSAP(matcher string, f Callback) {
	re := regexp.MustCompile(fmt.Sprintf("^(?i)%s$", matcher))
	d.Register("NSAP", re, f)
}

// Helper function to register a callback for NSEC queries.
// The matcher is given as a string, which is compiled to a regular expression
// (using regexp.MustCompile) with the following rules:
//
// * The regexp is anchored to the start of the match string("^" at start)
// * The case-insensitivity option is added "(?i)"
// * The regexp is anchored to the end of the match string ("$" at end)
//
// If any of these options are unwelcome, you can use the DSL.Register and pass
// a regexp and the "NSEC" string directly.
func (d *DSL) NSEC(matcher string, f Callback) {
	re := regexp.MustCompile(fmt.Sprintf("^(?i)%s$", matcher))
	d.Register("NSEC", re, f)
}

// Helper function to register a callback for NULL queries.
// The matcher is given as a string, which is compiled to a regular expression
// (using regexp.MustCompile) with the following rules:
//
// * The regexp is anchored to the start of the match string("^" at start)
// * The case-insensitivity option is added "(?i)"
// * The regexp is anchored to the end of the match string ("$" at end)
//
// If any of these options are unwelcome, you can use the DSL.Register and pass
// a regexp and the "NULL" string directly.
func (d *DSL) NULL(matcher string, f Callback) {
	re := regexp.MustCompile(fmt.Sprintf("^(?i)%s$", matcher))
	d.Register("NULL", re, f)
}

// Helper function to register a callback for NXT queries.
// The matcher is given as a string, which is compiled to a regular expression
// (using regexp.MustCompile) with the following rules:
//
// * The regexp is anchored to the start of the match string("^" at start)
// * The case-insensitivity option is added "(?i)"
// * The regexp is anchored to the end of the match string ("$" at end)
//
// If any of these options are unwelcome, you can use the DSL.Register and pass
// a regexp and the "NXT" string directly.
func (d *DSL) NXT(matcher string, f Callback) {
	re := regexp.MustCompile(fmt.Sprintf("^(?i)%s$", matcher))
	d.Register("NXT", re, f)
}

// Helper function to register a callback for OPENPGPKEY queries.
// The matcher is given as a string, which is compiled to a regular expression
// (using regexp.MustCompile) with the following rules:
//
// * The regexp is anchored to the start of the match string("^" at start)
// * The case-insensitivity option is added "(?i)"
// * The regexp is anchored to the end of the match string ("$" at end)
//
// If any of these options are unwelcome, you can use the DSL.Register and pass
// a regexp and the "OPENPGPKEY" string directly.
func (d *DSL) OPENPGPKEY(matcher string, f Callback) {
	re := regexp.MustCompile(fmt.Sprintf("^(?i)%s$", matcher))
	d.Register("OPENPGPKEY", re, f)
}

// Helper function to register a callback for OPT queries.
// The matcher is given as a string, which is compiled to a regular expression
// (using regexp.MustCompile) with the following rules:
//
// * The regexp is anchored to the start of the match string("^" at start)
// * The case-insensitivity option is added "(?i)"
// * The regexp is anchored to the end of the match string ("$" at end)
//
// If any of these options are unwelcome, you can use the DSL.Register and pass
// a regexp and the "OPT" string directly.
func (d *DSL) OPT(matcher string, f Callback) {
	re := regexp.MustCompile(fmt.Sprintf("^(?i)%s$", matcher))
	d.Register("OPT", re, f)
}

// Helper function to register a callback for PTR queries.
// The matcher is given as a string, which is compiled to a regular expression
// (using regexp.MustCompile) with the following rules:
//
// * The regexp is anchored to the start of the match string("^" at start)
// * The case-insensitivity option is added "(?i)"
// * The regexp is anchored to the end of the match string ("$" at end)
//
// If any of these options are unwelcome, you can use the DSL.Register and pass
// a regexp and the "PTR" string directly.
func (d *DSL) PTR(matcher string, f Callback) {
	re := regexp.MustCompile(fmt.Sprintf("^(?i)%s$", matcher))
	d.Register("PTR", re, f)
}

// Helper function to register a callback for PX queries.
// The matcher is given as a string, which is compiled to a regular expression
// (using regexp.MustCompile) with the following rules:
//
// * The regexp is anchored to the start of the match string("^" at start)
// * The case-insensitivity option is added "(?i)"
// * The regexp is anchored to the end of the match string ("$" at end)
//
// If any of these options are unwelcome, you can use the DSL.Register and pass
// a regexp and the "PX" string directly.
func (d *DSL) PX(matcher string, f Callback) {
	re := regexp.MustCompile(fmt.Sprintf("^(?i)%s$", matcher))
	d.Register("PX", re, f)
}

// Helper function to register a callback for RKEY queries.
// The matcher is given as a string, which is compiled to a regular expression
// (using regexp.MustCompile) with the following rules:
//
// * The regexp is anchored to the start of the match string("^" at start)
// * The case-insensitivity option is added "(?i)"
// * The regexp is anchored to the end of the match string ("$" at end)
//
// If any of these options are unwelcome, you can use the DSL.Register and pass
// a regexp and the "RKEY" string directly.
func (d *DSL) RKEY(matcher string, f Callback) {
	re := regexp.MustCompile(fmt.Sprintf("^(?i)%s$", matcher))
	d.Register("RKEY", re, f)
}

// Helper function to register a callback for RP queries.
// The matcher is given as a string, which is compiled to a regular expression
// (using regexp.MustCompile) with the following rules:
//
// * The regexp is anchored to the start of the match string("^" at start)
// * The case-insensitivity option is added "(?i)"
// * The regexp is anchored to the end of the match string ("$" at end)
//
// If any of these options are unwelcome, you can use the DSL.Register and pass
// a regexp and the "RP" string directly.
func (d *DSL) RP(matcher string, f Callback) {
	re := regexp.MustCompile(fmt.Sprintf("^(?i)%s$", matcher))
	d.Register("RP", re, f)
}

// Helper function to register a callback for RRSIG queries.
// The matcher is given as a string, which is compiled to a regular expression
// (using regexp.MustCompile) with the following rules:
//
// * The regexp is anchored to the start of the match string("^" at start)
// * The case-insensitivity option is added "(?i)"
// * The regexp is anchored to the end of the match string ("$" at end)
//
// If any of these options are unwelcome, you can use the DSL.Register and pass
// a regexp and the "RRSIG" string directly.
func (d *DSL) RRSIG(matcher string, f Callback) {
	re := regexp.MustCompile(fmt.Sprintf("^(?i)%s$", matcher))
	d.Register("RRSIG", re, f)
}

// Helper function to register a callback for RT queries.
// The matcher is given as a string, which is compiled to a regular expression
// (using regexp.MustCompile) with the following rules:
//
// * The regexp is anchored to the start of the match string("^" at start)
// * The case-insensitivity option is added "(?i)"
// * The regexp is anchored to the end of the match string ("$" at end)
//
// If any of these options are unwelcome, you can use the DSL.Register and pass
// a regexp and the "RT" string directly.
func (d *DSL) RT(matcher string, f Callback) {
	re := regexp.MustCompile(fmt.Sprintf("^(?i)%s$", matcher))
	d.Register("RT", re, f)
}

// Helper function to register a callback for SIG queries.
// The matcher is given as a string, which is compiled to a regular expression
// (using regexp.MustCompile) with the following rules:
//
// * The regexp is anchored to the start of the match string("^" at start)
// * The case-insensitivity option is added "(?i)"
// * The regexp is anchored to the end of the match string ("$" at end)
//
// If any of these options are unwelcome, you can use the DSL.Register and pass
// a regexp and the "SIG" string directly.
func (d *DSL) SIG(matcher string, f Callback) {
	re := regexp.MustCompile(fmt.Sprintf("^(?i)%s$", matcher))
	d.Register("SIG", re, f)
}

// Helper function to register a callback for SINK queries.
// The matcher is given as a string, which is compiled to a regular expression
// (using regexp.MustCompile) with the following rules:
//
// * The regexp is anchored to the start of the match string("^" at start)
// * The case-insensitivity option is added "(?i)"
// * The regexp is anchored to the end of the match string ("$" at end)
//
// If any of these options are unwelcome, you can use the DSL.Register and pass
// a regexp and the "SINK" string directly.
func (d *DSL) SINK(matcher string, f Callback) {
	re := regexp.MustCompile(fmt.Sprintf("^(?i)%s$", matcher))
	d.Register("SINK", re, f)
}

// Helper function to register a callback for SOA queries.
// The matcher is given as a string, which is compiled to a regular expression
// (using regexp.MustCompile) with the following rules:
//
// * The regexp is anchored to the start of the match string("^" at start)
// * The case-insensitivity option is added "(?i)"
// * The regexp is anchored to the end of the match string ("$" at end)
//
// If any of these options are unwelcome, you can use the DSL.Register and pass
// a regexp and the "SOA" string directly.
func (d *DSL) SOA(matcher string, f Callback) {
	re := regexp.MustCompile(fmt.Sprintf("^(?i)%s$", matcher))
	d.Register("SOA", re, f)
}

// Helper function to register a callback for SPF queries.
// The matcher is given as a string, which is compiled to a regular expression
// (using regexp.MustCompile) with the following rules:
//
// * The regexp is anchored to the start of the match string("^" at start)
// * The case-insensitivity option is added "(?i)"
// * The regexp is anchored to the end of the match string ("$" at end)
//
// If any of these options are unwelcome, you can use the DSL.Register and pass
// a regexp and the "SPF" string directly.
func (d *DSL) SPF(matcher string, f Callback) {
	re := regexp.MustCompile(fmt.Sprintf("^(?i)%s$", matcher))
	d.Register("SPF", re, f)
}

// Helper function to register a callback for SRV queries.
// The matcher is given as a string, which is compiled to a regular expression
// (using regexp.MustCompile) with the following rules:
//
// * The regexp is anchored to the start of the match string("^" at start)
// * The case-insensitivity option is added "(?i)"
// * The regexp is anchored to the end of the match string ("$" at end)
//
// If any of these options are unwelcome, you can use the DSL.Register and pass
// a regexp and the "SRV" string directly.
func (d *DSL) SRV(matcher string, f Callback) {
	re := regexp.MustCompile(fmt.Sprintf("^(?i)%s$", matcher))
	d.Register("SRV", re, f)
}

// Helper function to register a callback for SSHFP queries.
// The matcher is given as a string, which is compiled to a regular expression
// (using regexp.MustCompile) with the following rules:
//
// * The regexp is anchored to the start of the match string("^" at start)
// * The case-insensitivity option is added "(?i)"
// * The regexp is anchored to the end of the match string ("$" at end)
//
// If any of these options are unwelcome, you can use the DSL.Register and pass
// a regexp and the "SSHFP" string directly.
func (d *DSL) SSHFP(matcher string, f Callback) {
	re := regexp.MustCompile(fmt.Sprintf("^(?i)%s$", matcher))
	d.Register("SSHFP", re, f)
}

// Helper function to register a callback for TA queries.
// The matcher is given as a string, which is compiled to a regular expression
// (using regexp.MustCompile) with the following rules:
//
// * The regexp is anchored to the start of the match string("^" at start)
// * The case-insensitivity option is added "(?i)"
// * The regexp is anchored to the end of the match string ("$" at end)
//
// If any of these options are unwelcome, you can use the DSL.Register and pass
// a regexp and the "TA" string directly.
func (d *DSL) TA(matcher string, f Callback) {
	re := regexp.MustCompile(fmt.Sprintf("^(?i)%s$", matcher))
	d.Register("TA", re, f)
}

// Helper function to register a callback for TALINK queries.
// The matcher is given as a string, which is compiled to a regular expression
// (using regexp.MustCompile) with the following rules:
//
// * The regexp is anchored to the start of the match string("^" at start)
// * The case-insensitivity option is added "(?i)"
// * The regexp is anchored to the end of the match string ("$" at end)
//
// If any of these options are unwelcome, you can use the DSL.Register and pass
// a regexp and the "TALINK" string directly.
func (d *DSL) TALINK(matcher string, f Callback) {
	re := regexp.MustCompile(fmt.Sprintf("^(?i)%s$", matcher))
	d.Register("TALINK", re, f)
}

// Helper function to register a callback for TKEY queries.
// The matcher is given as a string, which is compiled to a regular expression
// (using regexp.MustCompile) with the following rules:
//
// * The regexp is anchored to the start of the match string("^" at start)
// * The case-insensitivity option is added "(?i)"
// * The regexp is anchored to the end of the match string ("$" at end)
//
// If any of these options are unwelcome, you can use the DSL.Register and pass
// a regexp and the "TKEY" string directly.
func (d *DSL) TKEY(matcher string, f Callback) {
	re := regexp.MustCompile(fmt.Sprintf("^(?i)%s$", matcher))
	d.Register("TKEY", re, f)
}

// Helper function to register a callback for TLSA queries.
// The matcher is given as a string, which is compiled to a regular expression
// (using regexp.MustCompile) with the following rules:
//
// * The regexp is anchored to the start of the match string("^" at start)
// * The case-insensitivity option is added "(?i)"
// * The regexp is anchored to the end of the match string ("$" at end)
//
// If any of these options are unwelcome, you can use the DSL.Register and pass
// a regexp and the "TLSA" string directly.
func (d *DSL) TLSA(matcher string, f Callback) {
	re := regexp.MustCompile(fmt.Sprintf("^(?i)%s$", matcher))
	d.Register("TLSA", re, f)
}

// Helper function to register a callback for TSIG queries.
// The matcher is given as a string, which is compiled to a regular expression
// (using regexp.MustCompile) with the following rules:
//
// * The regexp is anchored to the start of the match string("^" at start)
// * The case-insensitivity option is added "(?i)"
// * The regexp is anchored to the end of the match string ("$" at end)
//
// If any of these options are unwelcome, you can use the DSL.Register and pass
// a regexp and the "TSIG" string directly.
func (d *DSL) TSIG(matcher string, f Callback) {
	re := regexp.MustCompile(fmt.Sprintf("^(?i)%s$", matcher))
	d.Register("TSIG", re, f)
}

// Helper function to register a callback for TXT queries.
// The matcher is given as a string, which is compiled to a regular expression
// (using regexp.MustCompile) with the following rules:
//
// * The regexp is anchored to the start of the match string("^" at start)
// * The case-insensitivity option is added "(?i)"
// * The regexp is anchored to the end of the match string ("$" at end)
//
// If any of these options are unwelcome, you can use the DSL.Register and pass
// a regexp and the "TXT" string directly.
func (d *DSL) TXT(matcher string, f Callback) {
	re := regexp.MustCompile(fmt.Sprintf("^(?i)%s$", matcher))
	d.Register("TXT", re, f)
}

// Helper function to register a callback for TYPE queries.
// The matcher is given as a string, which is compiled to a regular expression
// (using regexp.MustCompile) with the following rules:
//
// * The regexp is anchored to the start of the match string("^" at start)
// * The case-insensitivity option is added "(?i)"
// * The regexp is anchored to the end of the match string ("$" at end)
//
// If any of these options are unwelcome, you can use the DSL.Register and pass
// a regexp and the "TYPE" string directly.
func (d *DSL) TYPE(matcher string, f Callback) {
	re := regexp.MustCompile(fmt.Sprintf("^(?i)%s$", matcher))
	d.Register("TYPE", re, f)
}

// Helper function to register a callback for UID queries.
// The matcher is given as a string, which is compiled to a regular expression
// (using regexp.MustCompile) with the following rules:
//
// * The regexp is anchored to the start of the match string("^" at start)
// * The case-insensitivity option is added "(?i)"
// * The regexp is anchored to the end of the match string ("$" at end)
//
// If any of these options are unwelcome, you can use the DSL.Register and pass
// a regexp and the "UID" string directly.
func (d *DSL) UID(matcher string, f Callback) {
	re := regexp.MustCompile(fmt.Sprintf("^(?i)%s$", matcher))
	d.Register("UID", re, f)
}

// Helper function to register a callback for UINFO queries.
// The matcher is given as a string, which is compiled to a regular expression
// (using regexp.MustCompile) with the following rules:
//
// * The regexp is anchored to the start of the match string("^" at start)
// * The case-insensitivity option is added "(?i)"
// * The regexp is anchored to the end of the match string ("$" at end)
//
// If any of these options are unwelcome, you can use the DSL.Register and pass
// a regexp and the "UINFO" string directly.
func (d *DSL) UINFO(matcher string, f Callback) {
	re := regexp.MustCompile(fmt.Sprintf("^(?i)%s$", matcher))
	d.Register("UINFO", re, f)
}

// Helper function to register a callback for UNSPEC queries.
// The matcher is given as a string, which is compiled to a regular expression
// (using regexp.MustCompile) with the following rules:
//
// * The regexp is anchored to the start of the match string("^" at start)
// * The case-insensitivity option is added "(?i)"
// * The regexp is anchored to the end of the match string ("$" at end)
//
// If any of these options are unwelcome, you can use the DSL.Register and pass
// a regexp and the "UNSPEC" string directly.
func (d *DSL) UNSPEC(matcher string, f Callback) {
	re := regexp.MustCompile(fmt.Sprintf("^(?i)%s$", matcher))
	d.Register("UNSPEC", re, f)
}

// Helper function to register a callback for URI queries.
// The matcher is given as a string, which is compiled to a regular expression
// (using regexp.MustCompile) with the following rules:
//
// * The regexp is anchored to the start of the match string("^" at start)
// * The case-insensitivity option is added "(?i)"
// * The regexp is anchored to the end of the match string ("$" at end)
//
// If any of these options are unwelcome, you can use the DSL.Register and pass
// a regexp and the "URI" string directly.
func (d *DSL) URI(matcher string, f Callback) {
	re := regexp.MustCompile(fmt.Sprintf("^(?i)%s$", matcher))
	d.Register("URI", re, f)
}

// Helper function to register a callback for WKS queries.
// The matcher is given as a string, which is compiled to a regular expression
// (using regexp.MustCompile) with the following rules:
//
// * The regexp is anchored to the start of the match string("^" at start)
// * The case-insensitivity option is added "(?i)"
// * The regexp is anchored to the end of the match string ("$" at end)
//
// If any of these options are unwelcome, you can use the DSL.Register and pass
// a regexp and the "WKS" string directly.
func (d *DSL) WKS(matcher string, f Callback) {
	re := regexp.MustCompile(fmt.Sprintf("^(?i)%s$", matcher))
	d.Register("WKS", re, f)
}
